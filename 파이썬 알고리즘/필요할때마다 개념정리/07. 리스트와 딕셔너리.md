## 1. 리스트
---
<br/>

파이썬의 리스트는 말 그대로 순서대로 저장하는 시퀀스이자 변경 가능한 목록을 말한다. 입력 순서가 유지되고 내부적으로는 동적 배열로 구현되어 있다.

<br/>

*   리스트는 다양한 기능을 제공하면서도 O(1)에 실행 가능한 연산들도 몇 가지 있다. 리스트 마지막에 요소를 `.append()` 로 추가하거나, 리스트 마지막 요소를 `pop()`으로 추출하거나, 원하는 인덱스의 요소를 조회하는 연산은 모두 O(1)이다.

<br/>

*   반면 요소를 삭제하너가 큐의 연산이기도 한 첫 번째 요소를 추출하는 pop(0)은 O(n)이다. 따라서 리스트에 주로 큐의 연산을 사용할 때는 주의가 필요하다. 이 경우 데크같은 자료형으로 성능을 높일 수 있다.

<br/>
<br/>

---

<br/>

<center> <리스트의 주요 연산 시간 복잡도> </center>  

<br/>

|연산|시간 복잡도|설명|
|:-:|:-:|:-:|
|`len(a)`|O(1)|전체 요소의 개수를 리턴한다.|
|`a[i]`|O(1)|인덱스 i의 요소를 가져온다.|
|`a[i:j]`|O(k)|i부터 j까지 슬라이스의 길이만큼인 k개의 요소를 가져온다. <br/> 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.|
|`elem in a`|O(n)|elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.|
|`a.count(elem)`|O(n)|elem 요소의 개수를 리턴한다.|
|`a.index(elem)`|O(n)|elem 요소의 인덱스를 리턴한다.|
|`a.append(elem)`|O(1)|리스트 마지막에 elem 요소를 추가한다.|
|`a.pop()`|O(1)|리스트 마지막 요소를 추출한다. 스택의 연산이다.|
|`a.pop(0)`|O(n)|리스트의 첫번째 요소를 추출한다. 큐의 연산이며 이 경우 전체 복사가 필요하므로 O(n)이다 <br/> 큐의 연산을 주로 사용한다면 리스트보단 O(1)에 가능한 데크(deque)를 권장함.|
|`del a[i]`|O(n)|i에 따라 다르다. 최악의 경우 O(n)이다.|
|`a.sort()`|O(n log n)|정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.|
|`min(a), max(a)`|O(n)|최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.|
|`a.reverse()`|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.|

<br/>

-> 리스트의 탐색 시 값의 존재 유무를 확인하려면 정렬된 경우에는 `이진 검색`이 효율적이다. 그러나 매번 정렬이 필요하고 대개는 리스트가 정렬된 상태가 아니기 때문에 리스트의 경우에는 모든 엘리먼트를 순차적으로 조회하는 형태로 구현되어있다. 이때 최악의 경우 항상 O(n)이 소요된다.


<br/>
<br/>

---

<br/>

<center> <리스트의 활용> </center>

<br/>


1. 리스트 선언 :  `a = list() OR a = []`

<br/>
 
2. 초기값 지정해 선언하거나 append로 추가 : `a = [1, 2, 3] OR a.append(4)` # 숫자, 문자, 불리언 모두 추가 가능

<br/>
 
3. 특정 위치에 인덱스 지정 후 요소 추가 : `a.insert(3, 5)` # 3번째 인덱스에 5 추가

<br/>
 
4. 홀수 번째 인덱스의 값만 가져오기 : `a[1:4:2]` # 세번째 파라미터는 단계의 의미이다.

<br/>
 
5. 리스트 요소 삭제하기(인덱스) : `del a[i]` # i번째 인덱스에 해당하는 요소 제거

<br/>
 
6. 리스트 요소 삭제하기(요소 값) : `a.remove(3)` # 3이라는 요소 값 제거

<br/>
 
7. 삭제될 값을 리턴하고 삭제 진행(스택의 pop) : `a.pop(3)` # 3번째 요소가 추출되고 원래 리스트에서는 삭제됨

<br/>

## 2. 딕셔너리

---

<br/>

파이썬의 딕셔너리는 키/값 구조로 이뤄진 딕셔너리를 말한다. 파이썬 3.7+ 에서는 입력 순서가 유지되며, 내부적으로는 해시 테이블(Hash Table)로 구현되어 있다. 

<br/>

인덱스를 숫자로만 지정할 수 있는 리스트와 달리 딕셔너리는 문자를 포함해 다양한 타입을 키로 사용할 수 있다. 

특히 파이썬의 딕셔너리는 해시할 수만 있다면 숫자뿐만 아니라 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있다.

이 과정을 `해싱`이라고 하며 해시 테이블을 이용해 자료를 저장한다. 해시 테이블은 다양한 타입을 키로 지원하면서 입력과 조회 모두 O(1)에 가능하다.

최악의 경우 O(n)이 될 수 있으나 대부분의 경우 훨씬 더 빨리 실행되며, 분할 상환 분석에 따른 시간 복잡도는 O(1)이다.


<br/>
<br/>

<center> <딕셔너리의 주요 연산 시간 복잡도> </center>

|연산|시간 복잡도|설명|
|:---:|:---:|:---:|
|`len(a)`|O(1)|요소의 개수를 리턴한다.|
|`a[key]`|O(1)|키를 조회하여 값을 리턴한다.|
|`a[key] = value`|O(1)|키/값을 삽입한다.|
|`key in a`|O(1)|딕셔너리에 키가 존재하는지 확인한다.|

<br/>

-> 이처럼 딕셔너리는 대부분의 연산이 O(1)에 처리 가능한 매우 우수한 자료형이다. 키/값 구조의 데이터를 저장하는 유용한 자료형으로서 리스트만큼 매우 빈번하게 사용된다. 

원래 파이썬 딕셔너리는 입력 순서가 유지되지 않았다. 파이썬 3.6 이하에서는 입력 순서가 유지되지 않아 `collections.OrderDict()`라는 별도 자료형을 제공했지만 3.7 부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선됐다.

이 외에도 조회 시 항상 디폴트 값을 생성해 키 오류를 방지하는 `collections.defaultdict()`와 요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅하는 `collcetions.Counter()` 등이 있다.

---

<br/>

<center> <딕셔너리의 활용> </center>

<br/>


1. 딕셔너리 선언 :  `a = dict() OR a = {}`

<br/>
 
2. 초기값 지정해 선언하거나 나중에 별도 선언 가능 : `a = {'key1' : 'value1', 'key2' : 'value2'} /  a['Key3'] = 'value3' `

<br/>

3. `for 반복문`과 `.items()`로 키와 값을 각각 꺼내올 수 있다.

<br/>

4. 딕셔너리 삭제 : `del a['key1']`

---

* 딕셔너리 모듈

    * 1. defaultdict 객체 : `defaultdict` 객체는 존재하지 않는 키를 조회할 경우, 에러 메세지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다. 실제로는 collections.defaultdict 클래스를 갖는다.

        <br/>

        ```
        >>> a = collcetions.defaultdict(int)

        >>> a['A'] = 5

        >>> a['B'] = 4

        >>> a

        defaultdict(<class 'int'>, {'A' : 5, 'B' : 4})

        ```
        <br/>

        여기서 A와 B에 5와 4를 할당했다. 이때
        
        <br/>

        ```
        >>> a['C'] += 1

        >>> a

        defaultdict(<class 'int'>, {'A' : 5, 'B' : 4, 'C' : 1})
        ```

        <br/>

        C는 존재하지 않는 키이기 때문에 원래는 KeyError가 발생하겠지만, defaultdict 객체는 에러 없이 바로 +1 연산이 가능하고 이 경우 디폴트인 0을 기준으로 자동으로 생성한 후 여기에 1을 더해 최종적으로 1이 만들어진다.

    <br/>

    * 2. Counter 객체 : `Counter` 객체는 아이템에 대한 개수를 계산해 딕셔너리로 리턴하며, 다음과 같이 사용한다.

        <br/>

        ```
        >>> a = [1, 2, 3, 4, 5, 5, 5, 6, 6]

        >>> b = collections.Counter(a)

        >>> b

        Counter({5: 3, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})
        ```

        <br/>

        Counter 객체는 이처럼 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간 딕셔너리를 생성한다. 실제로는 다음과 같이 딕셔너리를 한번 더 래핑한 collections.Counter 클래스를 갖는다.

        가장 빈도가 높은 n개의 요소를 추출하고 싶다면 `b.most_common(n)` 를 사용한다.

    <br/>

    * 3. OrderedDict 객체 : 입력 순서가 유지되는 별도의 객체를 제공한다. 다음과 같이 입력값을 부여할 경우 `OrderedDict`는 입력 그대로 순서가 유지된다.

        <br/>

        ```
        >>> collections.OrderedDict({'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2})
        ```